I would not be comfortable with merging this into headinganchors and enabling it by
default for two main reasons:

* it adds a new dependency on [[!cpan Text::Unidecode]]
* Text::Unidecode specifically documents its transliteration as not being stable
  across versions

There are several "slugify" libraries available other than Text::Unidecode.
It isn't clear to me which one is the best. Pandoc also documents
[an algorithm for generating slugs](http://pandoc.org/MANUAL.html#extension-auto_identifiers),
and it would be nice if our fallback implementation (with i18n disabled) was compatible
with Pandoc's, at least for English text.

However! In HTML5, IDs are allowed to contain anything except _space characters_
(space, newline, tab, CR, FF), so we could consider just passing non-ASCII
through the algorithm untouched. This [example link to a Russian
anchor name](#пример) (the output of putting "example" into English-to-Russian
Google Translate) hopefully works? (Use a small browser window to make it
clearer where it goes)

So perhaps we could try this Unicode-aware version of what Pandoc documents:

* Remove footnote links if any (this might have to be heuristic, or we could
  skip this step for a first implementation)
* Take only the plain text, no markup (passing the heading through HTML::Parser
  and collecting only the text nodes would be the fully-correct version of this,
  or we could fake it with regexes and be at least mostly correct)
* Strip punctuation, using some Unicode-aware definition of what is punctuation:
  perhaps `s/[^-\w_. ]//gu;` (delete anything that is not a (Unicode-aware) word
  character, hyphen-minus, underscore, dot or space)
* Replace spaces with hyphen-minus
* Force to lower-case with `lc`
* Strip leading digits and punctuation
* If the string is empty, use `section`
* If we already generated a matching identifier, append `-1`, `-2`, etc. until we find
  an unused identifier

(Or to provide better uniqueness, we could parse the document looking for any existing
ID, then append `-1`, `-2` to each generated ID until there is no collision.)

This would give us, for example, `## Visiting 北京` → `id="visiting-北京"`
(whereas Text::Unidecode would instead transliterate, resulting in
`id="visiting-bei-jing"`).

To use these IDs in fragments, I would be inclined to rely on browsers
supporting [IRIs](https://tools.ietf.org/html/rfc3987): `<a href="#visiting-北京">`.

--[[smcv]]


----

Documentation says:

> _Also note that all heading attributes are overriden with the ID tag. If this
> is not desirable, we'd need to fire up a full HTML::Parser or do some more
> regex magic to preserve the attributes other than id= which we want to keep._

I think this is a bug, particularly if you are using Pandoc's
[header attributes](http://pandoc.org/MANUAL.html#extension-header_attributes)
or similar.

I think we should try to use an existing ID before generating our own, with the
generation step as a fallback, just like Pandoc does. If a htmlize layer like
Text::MultiMarkdown or Pandoc is generating worse IDs than this plugin, the
the right solution to that is to send a bug report / feature request to
make its IDs as good as this plugin's, or turn off ID generation in the
htmlize layer, or stop using Text::MultiMarkdown.

--[[smcv]]

----

<pre>Some long scrollable text
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
<span id="пример">Example fragment ID in Russian should point here</span>
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.</pre>
